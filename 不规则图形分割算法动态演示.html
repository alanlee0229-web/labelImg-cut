<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>不规则图形分割算法动态演示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.2rem;
        }
        
        .algorithms {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .algorithm-card {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: transform 0.3s ease;
        }
        
        .algorithm-card:hover {
            transform: translateY(-5px);
        }
        
        .card-header {
            padding: 15px;
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        
        .card-body {
            padding: 15px;
            height: 200px;
            position: relative;
        }
        
        .canvas-container {
            width: 100%;
            height: 100%;
            border: 1px solid #eee;
            border-radius: 5px;
            overflow: hidden;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .card-footer {
            padding: 15px;
            background-color: #f8f9fa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        button {
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .description {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .description h2 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .description p {
            margin-bottom: 15px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: #7f8c8d;
        }
        
        @media (max-width: 768px) {
            .algorithms {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>不规则图形分割算法动态演示</h1>
            <p class="subtitle">多种高效分割算法的可视化展示与比较</p>
        </header>
        
        <div class="description">
            <h2>算法概述</h2>
            <p>本页面展示了五种针对不规则图形分割的优化算法，每种算法都有其独特的分割策略和适用场景。</p>
            <p>点击各算法下方的"开始演示"按钮，观察不同算法的分割过程和效果。</p>
        </div>
        
        <div class="algorithms">
            <!-- 算法1: 基于区域覆盖的自适应分割 -->
            <div class="algorithm-card">
                <div class="card-header">基于区域覆盖的自适应分割</div>
                <div class="card-body">
                    <div class="canvas-container">
                        <canvas id="canvas1"></canvas>
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="startAlgorithm(1)">开始演示</button>
                    <span>状态: <span id="status1">等待开始</span></span>
                </div>
            </div>
            
            <!-- 算法2: 基于密度采样的智能分割 -->
            <div class="algorithm-card">
                <div class="card-header">基于密度采样的智能分割</div>
                <div class="card-body">
                    <div class="canvas-container">
                        <canvas id="canvas2"></canvas>
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="startAlgorithm(2)">开始演示</button>
                    <span>状态: <span id="status2">等待开始</span></span>
                </div>
            </div>
            
            <!-- 算法3: 基于Voronoi图的自适应分割 -->
            <div class="algorithm-card">
                <div class="card-header">基于Voronoi图的自适应分割</div>
                <div class="card-body">
                    <div class="canvas-container">
                        <canvas id="canvas3"></canvas>
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="startAlgorithm(3)">开始演示</button>
                    <span>状态: <span id="status3">等待开始</span></span>
                </div>
            </div>
            
            <!-- 算法4: 基于贪心算法的最小覆盖集 -->
            <div class="algorithm-card">
                <div class="card-header">基于贪心算法的最小覆盖集</div>
                <div class="card-body">
                    <div class="canvas-container">
                        <canvas id="canvas4"></canvas>
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="startAlgorithm(4)">开始演示</button>
                    <span>状态: <span id="status4">等待开始</span></span>
                </div>
            </div>
            
            <!-- 算法5: 混合策略算法 -->
            <div class="algorithm-card">
                <div class="card-header">混合策略算法</div>
                <div class="card-body">
                    <div class="canvas-container">
                        <canvas id="canvas5"></canvas>
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="startAlgorithm(5)">开始演示</button>
                    <span>状态: <span id="status5">等待开始</span></span>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="resetAll()">重置所有算法</button>
            <button onclick="startAll()">同时运行所有算法</button>
        </div>
        
        <div class="description">
            <h2>算法性能比较</h2>
            <p>在相同的不规则图形上，不同算法的表现：</p>
            <ul>
                <li><strong>区域覆盖自适应分割</strong>: 适合边界复杂的图形，分割块贴合度高</li>
                <li><strong>密度采样智能分割</strong>: 在内部结构复杂的图形上表现优异</li>
                <li><strong>Voronoi图分割</strong>: 生成自然的分割边界，适合有机形状</li>
                <li><strong>贪心最小覆盖集</strong>: 最大化覆盖率，特别适合复杂凹形</li>
                <li><strong>混合策略算法</strong>: 综合性能最佳，适应多种场景</li>
            </ul>
        </div>
        
        <footer>
            <p>不规则图形分割算法可视化演示 &copy; 2023</p>
        </footer>
    </div>

    <script>
        // 初始化所有画布
        const canvases = {};
        const ctxs = {};
        const animationIds = {};
        const statusElements = {};
        
        // 初始化函数
        function initialize() {
            for (let i = 1; i <= 5; i++) {
                const canvasId = "canvas" + i;
                const statusId = "status" + i;
                
                canvases[i] = document.getElementById(canvasId);
                ctxs[i] = canvases[i].getContext('2d');
                statusElements[i] = document.getElementById(statusId);
                
                // 设置画布尺寸
                const container = canvases[i].parentElement;
                canvases[i].width = container.clientWidth;
                canvases[i].height = container.clientHeight;
                
                // 初始绘制不规则图形
                drawIrregularShape(ctxs[i], canvases[i].width, canvases[i].height);
            }
        }
        
        // 绘制不规则图形
        function drawIrregularShape(ctx, width, height) {
            ctx.clearRect(0, 0, width, height);
            
            // 绘制背景
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            // 绘制不规则图形
            ctx.beginPath();
            ctx.moveTo(width * 0.2, height * 0.2);
            ctx.bezierCurveTo(width * 0.4, height * 0.1, width * 0.6, height * 0.3, width * 0.8, height * 0.2);
            ctx.bezierCurveTo(width * 0.9, height * 0.4, width * 0.7, height * 0.7, width * 0.8, height * 0.8);
            ctx.bezierCurveTo(width * 0.6, height * 0.9, width * 0.4, height * 0.7, width * 0.2, height * 0.8);
            ctx.bezierCurveTo(width * 0.1, height * 0.6, width * 0.1, height * 0.4, width * 0.2, height * 0.2);
            ctx.closePath();
            
            ctx.fillStyle = '#e8f4f8';
            ctx.fill();
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // 算法1: 基于区域覆盖的自适应分割
        function algorithm1(canvasId) {
            const canvas = canvases[canvasId];
            const ctx = ctxs[canvasId];
            const width = canvas.width;
            const height = canvas.height;
            
            let step = 0;
            const maxSteps = 20;
            
            function animate() {
                if (step >= maxSteps) {
                    statusElements[canvasId].textContent = "完成";
                    return;
                }
                
                statusElements[canvasId].textContent = "步骤 " + (step+1) + "/" + maxSteps;
                
                // 清除画布并重新绘制不规则图形
                drawIrregularShape(ctx, width, height);
                
                // 添加新的分割块
                const blockSize = width / 8;
                const rows = Math.ceil(height / blockSize);
                const cols = Math.ceil(width / blockSize);
                
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const x = c * blockSize;
                        const y = r * blockSize;
                        
                        // 随机决定是否绘制此块（模拟自适应过程）
                        if (Math.random() > 0.3 || step > 15) {
                            // 检查块是否在不规则图形内（简化检查）
                            const centerX = x + blockSize/2;
                            const centerY = y + blockSize/2;
                            
                            if (isPointInShape(centerX, centerY, width, height)) {
                                ctx.fillStyle = "rgba(52, 152, 219, " + (0.3 + 0.7 * step/maxSteps) + ")";
                                ctx.fillRect(x, y, blockSize, blockSize);
                                ctx.strokeStyle = '#2980b9';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(x, y, blockSize, blockSize);
                            }
                        }
                    }
                }
                
                step++;
                animationIds[canvasId] = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // 算法2: 基于密度采样的智能分割
        function algorithm2(canvasId) {
            const canvas = canvases[canvasId];
            const ctx = ctxs[canvasId];
            const width = canvas.width;
            const height = canvas.height;
            
            let step = 0;
            const maxSteps = 15;
            const points = [];
            
            // 生成采样点
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                if (isPointInShape(x, y, width, height)) {
                    points.push({x, y});
                }
            }
            
            function animate() {
                if (step >= maxSteps) {
                    statusElements[canvasId].textContent = "完成";
                    return;
                }
                
                statusElements[canvasId].textContent = "步骤 " + (step+1) + "/" + maxSteps;
                
                // 清除画布并重新绘制不规则图形
                drawIrregularShape(ctx, width, height);
                
                // 绘制采样点
                points.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#e74c3c';
                    ctx.fill();
                });
                
                // 绘制分割块（基于采样点密度）
                const blockSize = width / 6;
                
                for (let i = 0; i <= width; i += blockSize) {
                    for (let j = 0; j <= height; j += blockSize) {
                        // 计算该区域内的点数
                        let count = 0;
                        points.forEach(point => {
                            if (point.x >= i && point.x < i + blockSize && 
                                point.y >= j && point.y < j + blockSize) {
                                count++;
                            }
                        });
                        
                        // 根据密度调整块的大小和透明度
                        if (count > 0) {
                            const sizeFactor = 0.5 + (count / 10);
                            const alpha = 0.2 + (count / 15);
                            
                            ctx.fillStyle = "rgba(231, 76, 60, " + alpha + ")";
                            ctx.fillRect(
                                i + (blockSize - blockSize * sizeFactor) / 2,
                                j + (blockSize - blockSize * sizeFactor) / 2,
                                blockSize * sizeFactor,
                                blockSize * sizeFactor
                            );
                            
                            ctx.strokeStyle = '#c0392b';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(
                                i + (blockSize - blockSize * sizeFactor) / 2,
                                j + (blockSize - blockSize * sizeFactor) / 2,
                                blockSize * sizeFactor,
                                blockSize * sizeFactor
                            );
                        }
                    }
                }
                
                step++;
                animationIds[canvasId] = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // 算法3: 基于Voronoi图的自适应分割
        function algorithm3(canvasId) {
            const canvas = canvases[canvasId];
            const ctx = ctxs[canvasId];
            const width = canvas.width;
            const height = canvas.height;
            
            let step = 0;
            const maxSteps = 20;
            const sites = [];
            
            // 生成Voronoi站点
            for (let i = 0; i < 25; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                if (isPointInShape(x, y, width, height)) {
                    sites.push({x, y});
                }
            }
            
            function animate() {
                if (step >= maxSteps) {
                    statusElements[canvasId].textContent = "完成";
                    return;
                }
                
                statusElements[canvasId].textContent = "步骤 " + (step+1) + "/" + maxSteps;
                
                // 清除画布并重新绘制不规则图形
                drawIrregularShape(ctx, width, height);
                
                // 绘制Voronoi站点
                sites.forEach(site => {
                    ctx.beginPath();
                    ctx.arc(site.x, site.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#9b59b6';
                    ctx.fill();
                });
                
                // 简化的Voronoi图绘制（实际实现需要更复杂的计算）
                for (let x = 0; x < width; x += 10) {
                    for (let y = 0; y < height; y += 10) {
                        if (!isPointInShape(x, y, width, height)) continue;
                        
                        // 找到最近的站点
                        let minDist = Infinity;
                        let closestSite = null;
                        
                        sites.forEach(site => {
                            const dist = Math.sqrt((x - site.x) ** 2 + (y - site.y) ** 2);
                            if (dist < minDist) {
                                minDist = dist;
                                closestSite = site;
                            }
                        });
                        
                        if (closestSite) {
                            // 根据距离设置颜色
                            const colorValue = Math.min(255, minDist * 2);
                            ctx.fillStyle = "rgb(155, 89, " + colorValue + ")";
                            ctx.fillRect(x, y, 10, 10);
                        }
                    }
                }
                
                step++;
                animationIds[canvasId] = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // 算法4: 基于贪心算法的最小覆盖集
        function algorithm4(canvasId) {
            const canvas = canvases[canvasId];
            const ctx = ctxs[canvasId];
            const width = canvas.width;
            const height = canvas.height;
            
            let step = 0;
            const maxSteps = 12;
            const blocks = [];
            
            function animate() {
                if (step >= maxSteps) {
                    statusElements[canvasId].textContent = "完成";
                    return;
                }
                
                statusElements[canvasId].textContent = "步骤 " + (step+1) + "/" + maxSteps;
                
                // 清除画布并重新绘制不规则图形
                drawIrregularShape(ctx, width, height);
                
                // 添加新的分割块（贪心算法）
                if (step < maxSteps) {
                    // 随机生成一个新块（实际算法会寻找最大覆盖区域）
                    const blockSize = width / (4 + step/2);
                    const maxAttempts = 50;
                    
                    for (let attempt = 0; attempt < maxAttempts; attempt++) {
                        const x = Math.random() * (width - blockSize);
                        const y = Math.random() * (height - blockSize);
                        
                        // 检查块是否在不规则图形内有足够覆盖
                        if (isBlockInShape(x, y, blockSize, blockSize, width, height)) {
                            ctx.fillStyle = "rgba(46, 204, 113, " + (0.3 + 0.7 * step/maxSteps) + ")";
                            ctx.fillRect(x, y, blockSize, blockSize);
                            ctx.strokeStyle = '#27ae60';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(x, y, blockSize, blockSize);
                            break;
                        }
                    }
                }
                
                // 绘制之前添加的所有块
                blocks.forEach(block => {
                    ctx.fillStyle = "rgba(46, 204, 113, " + (0.3 + 0.7 * block.step/maxSteps) + ")";
                    ctx.fillRect(block.x, block.y, block.size, block.size);
                    ctx.strokeStyle = '#27ae60';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(block.x, block.y, block.size, block.size);
                });
                
                // 记录当前块
                if (step < maxSteps) {
                    const blockSize = width / (4 + step/2);
                    const maxAttempts = 50;
                    
                    for (let attempt = 0; attempt < maxAttempts; attempt++) {
                        const x = Math.random() * (width - blockSize);
                        const y = Math.random() * (height - blockSize);
                        
                        if (isBlockInShape(x, y, blockSize, blockSize, width, height)) {
                            blocks.push({x, y, size: blockSize, step});
                            break;
                        }
                    }
                }
                
                step++;
                animationIds[canvasId] = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // 算法5: 混合策略算法
        function algorithm5(canvasId) {
            const canvas = canvases[canvasId];
            const ctx = ctxs[canvasId];
            const width = canvas.width;
            const height = canvas.height;
            
            let step = 0;
            const maxSteps = 25;
            
            function animate() {
                if (step >= maxSteps) {
                    statusElements[canvasId].textContent = "完成";
                    return;
                }
                
                statusElements[canvasId].textContent = "步骤 " + (step+1) + "/" + maxSteps;
                
                // 清除画布并重新绘制不规则图形
                drawIrregularShape(ctx, width, height);
                
                // 混合策略：结合网格和自适应
                const baseGridSize = width / 8;
                
                for (let i = 0; i < width; i += baseGridSize) {
                    for (let j = 0; j < height; j += baseGridSize) {
                        // 随机调整块的大小和位置（模拟自适应）
                        const offsetX = (Math.random() - 0.5) * baseGridSize * 0.4;
                        const offsetY = (Math.random() - 0.5) * baseGridSize * 0.4;
                        const sizeFactor = 0.7 + Math.random() * 0.6;
                        
                        const x = i + offsetX;
                        const y = j + offsetY;
                        const size = baseGridSize * sizeFactor;
                        
                        // 检查块是否在不规则图形内
                        if (isBlockInShape(x, y, size, size, width, height)) {
                            // 根据步骤设置颜色（模拟渐进过程）
                            const progress = step / maxSteps;
                            const r = Math.floor(230 * progress);
                            const g = Math.floor(126 * progress);
                            const b = Math.floor(34 * progress);
                            
                            ctx.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + (0.3 + 0.7 * progress) + ")";
                            ctx.fillRect(x, y, size, size);
                            
                            ctx.strokeStyle = "rgb(" + (r*0.8) + ", " + (g*0.8) + ", " + (b*0.8) + ")";
                            ctx.lineWidth = 1;
                            ctx.strokeRect(x, y, size, size);
                        }
                    }
                }
                
                step++;
                animationIds[canvasId] = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // 辅助函数：检查点是否在不规则图形内（简化版本）
        function isPointInShape(x, y, width, height) {
            // 这里使用一个简化的椭圆形状检查
            const centerX = width / 2;
            const centerY = height / 2;
            const radiusX = width * 0.35;
            const radiusY = height * 0.3;
            
            // 检查是否在主要椭圆内
            const dx = (x - centerX) / radiusX;
            const dy = (y - centerY) / radiusY;
            
            if (dx * dx + dy * dy <= 1) {
                return true;
            }
            
            // 检查是否在左侧小椭圆内
            const leftCenterX = width * 0.3;
            const leftCenterY = height * 0.5;
            const leftRadiusX = width * 0.15;
            const leftRadiusY = height * 0.2;
            
            const leftDx = (x - leftCenterX) / leftRadiusX;
            const leftDy = (y - leftCenterY) / leftRadiusY;
            
            if (leftDx * leftDx + leftDy * leftDy <= 1) {
                return true;
            }
            
            return false;
        }
        
        // 辅助函数：检查矩形块是否在不规则图形内（简化版本）
        function isBlockInShape(x, y, width, height, canvasWidth, canvasHeight) {
            // 检查四个角点
            const points = [
                {x: x, y: y},
                {x: x + width, y: y},
                {x: x, y: y + height},
                {x: x + width, y: y + height}
            ];
            
            let insideCount = 0;
            points.forEach(point => {
                if (isPointInShape(point.x, point.y, canvasWidth, canvasHeight)) {
                    insideCount++;
                }
            });
            
            // 如果超过一半的点在形状内，则认为块在形状内
            return insideCount >= 2;
        }
        
        
        // 启动指定算法
        function startAlgorithm(algorithmId) {
            // 停止当前动画（如果有）
            if (animationIds[algorithmId]) {
                cancelAnimationFrame(animationIds[algorithmId]);
            }
            
            // 重置画布
            drawIrregularShape(ctxs[algorithmId], canvases[algorithmId].width, canvases[algorithmId].height);
            
            // 启动算法
            switch(algorithmId) {
                case 1:
                    algorithm1(algorithmId);
                    break;
                case 2:
                    algorithm2(algorithmId);
                    break;
                case 3:
                    algorithm3(algorithmId);
                    break;
                case 4:
                    algorithm4(algorithmId);
                    break;
                case 5:
                    algorithm5(algorithmId);
                    break;
            }
        }
        
        // 重置所有算法
        function resetAll() {
            for (let i = 1; i <= 5; i++) {
                if (animationIds[i]) {
                    cancelAnimationFrame(animationIds[i]);
                }
                drawIrregularShape(ctxs[i], canvases[i].width, canvases[i].height);
                statusElements[i].textContent = "等待开始";
            }
        }
        
        // 同时运行所有算法
        function startAll() {
            for (let i = 1; i <= 5; i++) {
                startAlgorithm(i);
            }
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', function() {
            initialize();
        });
    </script>
</body>
</html>